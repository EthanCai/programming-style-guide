[TOC]

#  概述

日志用来记录用户操作、系统运行状态等，是一个系统的重要组成部分。现代软件系统，必须要考虑如何依靠良好的日志来帮助定位分析问题，保证系统可靠云行。

好的日志可以帮助开发和运维人员：

* 了解线上系统的运行状态
* 快速准确定位线上问题
* 发现系统瓶颈
* 预警系统潜在风险
* 挖掘产品最大价值
* ……

不好的日志导致：

1. 对系统的运行状态一知半解，甚至形成误导
2. 系统出现问题无法定位，或者需要花费巨大的时间和精力
3. 无法发现系统瓶颈，不知优化从何做起
4. 无法基于日志对系统运行过程中的错误和潜在风险进行监控和报警
5. 对挖掘用户行为和提升产品价值毫无帮助
6. ……

# 2. 日志的分类

日志从功能来说，可分为两种：status log、data log。

* status log
  + 用于
    - 帮助调试
    - 定位程序bug
    - 找到性能瓶颈
  + 比如
    - 请求入口和出口
    - 外部服务调用和返回
    - 资源消耗操作: 如读写文件等
    - 容错行为： 如云硬盘的副本修复操作
    - 程序异常： 如数据库无法连接
    - 后台操作：定期执行删除的线程
    - 启动、关闭、配置加载
* data log
  + 用于
    - 记录用户行为
    - 计费
    - 审计
  + 比如
    - 记录用户的交付操作行为
    - 记录使用的网络资源或者磁盘占用
    - 记录管理操作

本文主要介绍的是 status log。

# 3. 日志的内容

理想的日志中应该记录“不多”、“不少”的信息

所谓“不多”，是指不要在日志中记录无用的信息。实践中常见到的无用的日志有：

1. 能够放在一条日志里的东西，放在多条日志中输出
2. 预期会发生且能够被正常处理的异常，打印出一堆无用的堆栈
3. 开发人员在开发过程中为了调试方便而加入的“临时”日志

所谓“不少”，是指对于日志的使用者，不能从日志中得到所有需要的信息。例如：

1. 请求出错时不能通过日志直接来定位问题，而需要开发人员再临时增加日志并要求请求的发送者重新发送同样的请求才能定位问题
2. 无法确定服务中的后台任务是否按照期望执行
3. 无法确定服务的内存数据结构的状态
4. 无法确定服务的异常处理逻辑（如重试）是否正确执行
5. 无法确定服务启动时配置是否正确加载
6. 等等等等

输出日志时要考虑日志的使用者，例如如果日志主要由系统的运维人员来看，那就不能输出：

```
[INFO] RequestID:b1946ac92492d2347c6235b4d2611184, ErrorCode:1426
```

至少应该是：

```
[INFO] RequestID:b1946ac92492d2347c6235b4d2611184, ErrorCode:1426, Message: callback request (to http://example.com/callback) failed due to socket timeout
```

这样运维人员一眼就能清楚问题的原因，而不需要再通过开发来查看`ErrorCode`对应的具体错误。

整理一下通常情况下会遗漏的日志：

1. 系统的配置参数：系统在启动过程中通常会首先读启动参数，可以在系统启动后将这些参数输出到日志中，方便确认系统是按照期望的参数启动的
2. 后台定期执行的任务：如定期更新缓存的任务，可以记录任务开始时间，任务结束时间，更新了多少条缓存配置等等，这样可以掌握定期执行的任务的状态；
3. 异常处理逻辑：如对于分布式存储系统来说，当系统在一个存储节点上读数据失败时，需要去另一个数据节点上进行重试，可以将读数据失败这件事情记录下来，之后可以通过对日志的分析确认是否某些节点的磁盘可能存在故障。再比如，如果系统需要请求一个外部资源，可以将请求这个外部资源偶尔失败又重试成功这件事情记录下来，具体来说：
   
   ```;哦老婆；‘
   [INFO] RequestID:b1946ac92492d2347c6235b4d2611184, auth request (to http://auth1.example.com/v2) timeout ... 1 try
   [INFO] RequestID:b1946ac92492d2347c6235b4d2611184, auth request (to http://auth1.example.com/v2) timeout ... 2 try
   [INFO] RequestID:b1946ac92492d2347c6235b4d2611184, auth request (to http://auth1.example.com/v2) success
   ```
   
   要好于
   
   ```
   [INFO] RequestID:b1946ac92492d2347c6235b4d2611184, auth request (to http://auth1.example.com/v2) success
   ```
   
   因为前者可以让我们预判被依赖的服务器服务质量有风险，也许需要进行扩容
4. 日志中需要记录关键参数，出错时的关键原因等。例如：
   
   ```
   [INFO] RequestID:b1946ac92492d2347c6235b4d2611184, auth failed
   [INFO] RequestID:b1946ac92492d2347c6235b4d2611185, content digest does not match
   [INFO] RequestID:b1946ac92492d2347c6235b4d2611186, request ip not in whitelist就不如[INFO] RequestID:b1946ac92492d2347c6235b4d2611184, auth failed due to token expiration
   [INFO] RequestID:b1946ac92492d2347c6235b4d2611185, content digest does not match, expect 7b3f050bfa060b86ba781151c563c953, actual f60645e7107917250a6408f2f302d048
   [INFO] RequestID:b1946ac92492d2347c6235b4d2611186, request ip(=202.17.34.1) not in whitelist
   ```
   
   

# 4. 日志的级别

我们通常使用的日志库，将日志基本分为以下几个级别（从低到高）：

* **TRACE** - The TRACE Level designates **finer-grained informational events than the DEBUG**.（**比 DEBUG 更细粒度的信息，<u>没有用过，也没见过</u>**）
* **DEBUG** – The DEBUG Level designates **fine-grained informational events that are most useful to debug an application.**（**调试应用程序的细粒度信息**）
* **INFO** – The INFO level designates **informational messages that highlight the progress of the application at coarse-grained level.**（**宏观层面展示应用程序进展的信息**）
* **WARN** – The WARN level designates **potentially harmful situations**.（**潜在危害的场景**）
* **ERROR** – The ERROR level designates **error events that might still allow the application to continue running**.（**发生错误但仍然允许程序继续执行**）
* **FATAL** – The FATAL level designates **very severe error events that will presumably lead the application to abort**.（**导致应用程序中止的非常严重的错误**）

开发人员对于何种日志输出为何种级别通常有自己的理解，在实践中，是否所有的日志级别都有必要存在，哪些操作需要记入日志，哪种错误应该记为WARN级别，而哪种错误又为ERROR级别呢？

关于该问题，我们参考网上的一些讨论（StackOverflow上的一个[讨论](https://stackoverflow.com/questions/2031163/when-to-use-the-different-log-levels)），加上我们在平时运维过程中遇到的相关问题，进行了归纳：

* 一个项目各个日志级别的定义应该是清楚明确的，需要团队的每个开发人员共同遵守
* 即使是 DEBUG 级别的日志，也应该有一定的规范，要保证除了开发人员自己以外，包括测试人员和运维人员都可以方便地通过日志定位问题
* 对于日志级别的分类，有以下参考：
  + FATAL — 表示需要立即被处理的系统级错误。当该错误发生时，表示服务已经出现了某种程度的不可用，系统管理员需要立即介入。这属于最严重的日志级别，因此该日志级别必须慎用，如果这种级别的日志经常出现，则该日志也失去了意义。通常情况下，一个进程的生命周期中应该只记录一次FATAL级别的日志，即该进程遇到无法恢复的错误而退出时。当然，如果某个系统的子系统遇到了不可恢复的错误，那该子系统的调用方也可以记入FATAL级别日志，以便通过日志报警提醒系统管理员修复；
  + ERROR — 该级别的错误也需要马上被处理，但是紧急程度要低于FATAL级别。当ERROR错误发生时，已经影响了用户的正常访问。从该意义上来说，实际上ERROR错误和FATAL错误对用户的影响是相当的。FATAL相当于服务已经挂了，而ERROR是好死不如赖活着，然而活着却无法提供正常的服务，只能不断地打印ERROR日志。特别需要注意的是，ERROR和FATAL都属于服务器自己的异常，是需要马上得到人工介入并处理的。而对于用户自己操作不当，如请求参数错误等等，是绝对不应该记为ERROR日志的（在前端有参数校验的情况下，API碰到请求参数错误，也应当记录ERROR日志）
  + WARN — 该日志表示系统可能出现问题，也可能没有，这种情况如网络的波动等。对于那些目前还不是错误，然而不及时处理也会变为错误的情况，也可以记为WARN日志，例如一个存储系统的磁盘使用量超过阀值，或者系统中某个用户的存储配额快用完等等。对于WARN级别的日志，虽然不需要系统管理员马上处理，也是需要及时查看并处理的。因此此种级别的日志也不应太多，能不打WARN级别的日志，就尽量不要打
  + INFO — 该种日志记录系统的正常运行状态，例如某个子系统的初始化，某个请求的成功执行等等。通过查看INFO级别的日志，可以很快地对系统中出现的 WARN,ERROR,FATAL错误进行定位。INFO日志不宜过多，通常情况下，INFO级别的日志应该不大于DEBUG日志的10%
  + DEBUG or TRACE — 这两种日志具体的规范应该由项目组自己定义，该级别日志的主要作用是对系统每一步的运行状态进行精确的记录。通过该种日志，可以查看某一个操作每一步的执 行过程，可以准确定位是何种操作，何种参数，何种顺序导致了某种错误的发生。可以保证在不重现错误的情况下，也可以通过DEBUG（或TRACE）级别的日志对问题进行诊断。需要注意的是，DEBUG日志也需要规范日志格式，应该保证除了记录日志的开发人员自己外，其他的如运维，测试人员等也可以通过 DEBUG（或TRACE）日志来定位问题；

# 5. 日志实践

## 5.1. 不断优化日志

好的日志就像好的系统一样，绝不是一遍就可以做好的，而需要在实际的运维过程中，结合线上问题的定位，不断地进行优化。最关键的一点是，团队要重视日志优化这件事情，不要让日志的质量持续降低（当项目变大时，项目的代码也存在一样的问题，越写越乱）。

此处有以下几个比较好的实践：

* 在定位问题的过程中完善日志，如果定位问题花费了很长时间，那就说明系统日志还存在问题，需要进一步完善和优化；
* 需要思考是否可以通过优化日志，来提前预判该问题是否可能发生（如某种资源耗尽而导致的错误，可以对资源的使用情况进行记录）
* 定义好整个团队记录日志的规范，保证每个开发记录的日志格式统一；特别需要说明的是，对于DEBUG/TRACE级别的日志，也需要定义好清晰的格式，而不是由开发人员自由发挥；
* 整个团队（包括开发，运维和测试）定期对记录的日志内容进行Review；
* 开发做运维，通过在查问题的过程来优化日志记录的方式；
* 运维或测试在日志中发现的问题，都需要及时向开发人员反映；

## 5.2. 关于Tracing ID

日志内容中应当包含 tracing id，通过 tracing id 将一个请求在系统中的执行过程串联起来。

## 5.3. 日志的动态输出

DEBUG日志和INFO日志的一个重要的区别是，INFO日志用于记录常规的系统运行状态，请求的基本的输入和输出等，对于定位一般的问题已经足够了。而DEBUG日志则详细的记录了一个请求的处理过程，甚至是每一个函数的输入和输出结果，遇到一些隐藏比较深的问题时，必须要依赖DEBUG日志。

然而，由于DEBUG级别的日志数量比INFO级别的数量多很多（通常差一个数量级），如果长期在线上服务器开启DEBUG级别的日志输出，日志量太大。再比如，有时候仅仅是由于某一个用户的访问模式比较特殊导致了问题，如果将整个服务（特别是一个服务部署了很多台节点时）都临时调整为DEBUG级别日志输出，也非常不方便。

服务应该提供的服务降级功能，控制日志输出级别，比如以下的降级设定：

* Degrade0：默认情况下输出Info及以上级别日志
* Degrade1：输出Debug及以上级别日志
* Degrade2：输出Trace及以上级别日志

## 5.4. 慢操作日志

服务在接收到一个请求的时候，记录请求的接收时间（T1），在请求处理完成待发送的时候，会记录请求发送时间（T2），通常一个请求的日志都记为INFO级别，然而当出现请求处理时间（T2-T1）超过一定时间（如10s）时，可以将该日志提升为WARN级别。通过该方法，可以预先发现系统可能存在的一些问题。

同样的慢操作日志还可以用来记录系统一些外部依赖的处理时间，如一个服务可能依赖外部认证服务器来进行认证授权。通过记录每次认证请求的时间并将超出预期时间的请求日志采用WARN级别输出，可以尽早发现认证服务器是不是需要扩容等问题。

慢日志的时间阈值应该是可以动态调整的，这样在进行系统优化时，可以将该报警时间阈值逐渐调小，不断地对系统进行优化。

## 5.5. 日志的监控

通过对日志中的关键字进行监控，可以及时发现系统故障并报警，这对于保证服务的SLA至关重要。

服务的监控和报警是一个很大的话题，此处只说日志监控报警需要注意的一些问题：

1. 避免报警泛滥，只有需要运维、开发马上处理的错误才需要发送报警。这样做的原因是避免长期的报警骚扰让运维人员对报警不再敏感，最后真的报警来了时，变成了狼来了的传说；
3. 对于一些预警操作，例如某个服务需要重试多次才能成功，或者某个用户的配额快用完等等，可以通过定期汇报（每天一封报警邮件）的方式来反馈；
4. 每一次系统出现故障，都需要及时检查日志报警是否灵敏，日志报警的描述是否准确等，不断优化日志报警；

# 7. 总结

* 整体上
  + 充分认识到日志对于保持系统的稳定性关键作用
  + 整个团队（包括运维人员）需要对日志级别有明确的规定，什么日志输出为什么级别，什么级别的错误出现要如何处理等
* 日志格式、内容
  + 日志格式要统一规范
  + 需要定期对日志内容进行优化更新，目的就是通过日志快速准确地定位问题
  + 要明确不同日志的用途，对日志内容进行分类
  + 绝不要打印没有用的日志，防止无用日志淹没重要信息
  + 日志信息要准确全面，努力做到仅凭日志就可以定位问题
  + 日志的优化是一件需要持续不断投入精力的事，需要不断从错误中学习
  + 将一个请求的整个处理流程和唯一的tracing id关联起来
  + 支持动态日志输出，方便线上问题定位
* 日志的保存
  + 将错误日志输出到统一的位置进行分析
  + 要把日志的大小，如何切分，如何删除等作为规范建立起来
* 日志的观察、使用、监控
  + 新上线服务后一定要对日志进行观察，特别地，开发人员可以通过观察日志来确认新功能是否工作正常
  + 通过日志级别的提升来发现潜在问题
  + 对日志进行监控报警，比客户先发现系统问题

# 8. 参考

* [最佳日志实践（v2.0）](https://zhuanlan.zhihu.com/p/27363484)
* [掌握Linux系统日志记录的最佳实践方法](https://my.oschina.net/emacs_8784621/blog/17257271)
* [The Log: What every software engineer should know about real-time data's unifying abstraction | LinkedIn Engineering](https://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying)

